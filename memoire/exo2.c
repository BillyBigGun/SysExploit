#include <pthread.h>
#include <semaphore.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include "utils.h"
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>

#define FILE_SHR "/file"
  

int main(int argc, char *argv[])
{
    srand(time(NULL));

    // Creer mutex
    pthread_mutex_t mutex;
    pthread_mutex_init(&mutex, NULL);

    // Creation du tableau de valeur
    int n = atoi(argv[1]);
    int sizeTab = n*n*n*n*n;
    int *tableau =(int*)malloc(sizeTab*sizeof(int));
    
    for(int i = 0; i < sizeTab; i++){
        // Genere des valeurs aleatoires
        tableau[i] = rand();
    }

    // Creation de la memoire partagee
    int fd = shm_open(FILE_SHR, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
    ftruncate(fd, sizeTab*sizeof(int));
    void *ptr = mmap (NULL, n*sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

    close(fd);

    if(ptr == MAP_FAILED){
        printf("Error mmap\n");
        exit(EXIT_FAILURE);
    }
    int* sharedDataMinValues = (int*)(ptr);

    // Creation des processus
    int nombreValeurParProcess = sizeTab/n;

    for(int i = 0; i < n; ++i){
        int pid = fork();
        
        // Parcourir le tableau selon le nombre de processus
        if(pid == 0){
            int min = tableau[i*nombreValeurParProcess];

            for(int j = i*nombreValeurParProcess; j < (i+1)*nombreValeurParProcess; ++j){
                if(tableau[j] < min){
                    min = tableau[j];
                }
            }
            // Ecrire dans la memoire partagee
            // Lock le mutex
            pthread_mutex_lock(&mutex);
            sharedDataMinValues[i] = min;
            // Unlock le mutex
            pthread_mutex_unlock(&mutex);
            exit(0);
        }
        
    }  
    
    for(int i = 0; i < n; ++i){
        wait(NULL);
    } 


    // Comparer tous les min des processus
    int min = sharedDataMinValues[0];
    for(int i = 0; i < n; ++i){
        printf("Min process %d = %d\n", i, sharedDataMinValues[i]);
        if(sharedDataMinValues[i] < min){
            min = sharedDataMinValues[i];
        }
    }

    printf("Min = %d\n", min);
    // Fermer la memoire partagee
    if(-1 == munmap(ptr, sizeTab*sizeof(int))){
        printf("Error munmap\n");
        exit(EXIT_FAILURE);
    }

    // Delete le mutex
    pthread_mutex_destroy(&mutex);

    if(-1 == shm_unlink(FILE_SHR)){
        printf("Error shm_unlink\n");
        exit(EXIT_FAILURE);
    }


    // Delete tableau
    free(tableau);

    return 0;
}